datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

enum Role {
    STUDENT
    TUTOR
}

enum RequestStatus {
  PENDING
  MATCHED
  IN_PROGRESS
  COMPLETED
}

enum LessonStatus {
  PENDING
  ONGOING
  COMPLETED
}

// student model
model Student {
    id        String   @id @default(uuid())
    name      String
    email     String? @unique
    contact   String @unique
    password  String
    role      Role
    studentInfo StudentInfo[] @relation("studentInfo")
    tutorRequest TutorRequest[] 
    lesson Lesson[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// tutor model
model Tutor {
    id        String   @id @default(uuid())
    name      String
    email     String @unique
    contact   String @unique
    password  String
    role      Role
    tutorInfo tutorInfo[] @relation("tutorInfo")
    tutorCard tutorCard[] @relation("tutorCard")
    tutorRequestMatch TutorRequestMatch[]
    lesson Lesson[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// student info model
model StudentInfo {
    id        String   @id @default(uuid())
    availableTime String
    subjects     String[] //array of subjects
    address    String
    studentId String
    student   Student  @relation("studentInfo", fields: [studentId], references: [id] , onDelete: Cascade)
    
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// tutor info model
model tutorInfo{
    id        String   @id @default(uuid())
    experience String
    current_education String
    expected_salary String
    availableTime String
    subjects     String[]
    address    String
    classesWithSubjects Json
    asssigned Boolean @default(false)
    tutorId String
    tutor   Tutor  @relation("tutorInfo", fields: [tutorId], references: [id] , onDelete: Cascade)
    tutorCard tutorCard[] @relation("tutorInfoToTutorCard")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// tutor card model
model tutorCard{
    id String @id @default(uuid())
    rating Int
    tutorDemo Video?
    tutorId String
    tutor Tutor @relation("tutorCard", fields: [tutorId], references: [id] , onDelete: Cascade)
    tutroInfoId String
    tutorInfo tutorInfo @relation("tutorInfoToTutorCard",fields: [tutroInfoId], references: [id] , onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// video model
model Video{
    id String @id @default(uuid())
    videoUrl String
    thumbnailUrl String
    tutorCardId String @unique
    tutorCard tutorCard @relation(fields: [tutorCardId], references: [id] , onDelete: Cascade)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
}

// tutor request table (for matching students with tutors)
model TutorRequest {
  id          String   @id @default(uuid())
  studentId   String   @unique
  student     Student  @relation(fields: [studentId], references: [id])
  subjects    String[]
  selectedTutors Json
  matchedTutors TutorRequestMatch[]
  status      RequestStatus
  createdAt   DateTime @default(now())
  updatedAt  DateTime @updatedAt()
}

model TutorRequestMatch {
  id          String   @id @default(uuid())
  requestId   String
  request     TutorRequest @relation(fields: [requestId], references: [id])
  tutorId     String
  tutor       Tutor @relation(fields: [tutorId], references: [id])
  accepted    Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt  DateTime @updatedAt()
  notifiedAt DateTime?
}

model Lesson {
  id        String   @id @default(uuid())
  studentId String
  student   Student  @relation(fields: [studentId], references: [id])
  tutorId   String
  tutor     Tutor    @relation(fields: [tutorId], references: [id])
  subjects   String[]
  status    LessonStatus @default(PENDING)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
}